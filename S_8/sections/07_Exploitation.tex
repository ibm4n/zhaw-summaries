\section{Exploitation}

\textbf{Goals:}
\begin{itemize}[noitemsep]
  \item Understand the concept of Return-Oriented Programming (ROP)
  \item Learn to craft a ROP chain to achieve a specific goal
  \item Explain how ROP circumvents NX/DEP protection
  \item Understand conditions to bypass NX/DEP, ASLR, and stack canaries
\end{itemize}

\subsection{Protection Mechanisms (Revisited)}
{
  \textbf{ASLR (Address Space Layout Randomization):}
  \begin{itemize}[noitemsep]
    \item Randomizes base addresses of stack, heap, and libraries at runtime
    \item Makes it harder to predict memory layout for reliable exploitation
  \end{itemize}
  
  \item \textbf{NX/DEP (No-eXecute / Data Execution Prevention):}
  \begin{itemize}[noitemsep]
    \item Marks stack or heap memory regions as non-executable
    \item Prevents execution of injected shellcode
    \item Enforced by hardware and OS support
  \end{itemize}
  
  \item \textbf{Stack Canaries:}
  \begin{itemize}[noitemsep]
    \item Random value placed before return address
    \item Checked before function return to detect overwrites
    \item Abort execution if changed, thus preventing basic buffer overflows
  \end{itemize}
}

\subsection{Exploits – Concepts and Classification}
{
\textbf{Definition:} An exploit is software/data/command sequence abusing a vulnerability to cause unintended behavior.

\textbf{Types:}
\begin{itemize}[noitemsep]
  \item Local – exploit system where attacker already has access
  \item Remote – exploit over the network
  \item Client-side – requires user interaction (e.g., opening a file)
  \item Server-side – no user interaction needed
  \item 0-day – exploits unknown/unpatched vulnerabilities
\end{itemize}

\textbf{Examples:}
\begin{itemize}[noitemsep]
  \item Ping of Death (oversized packet)
  \item JavaScript browser exploit
  \item Netgear CVE-2017-5521 (redirect and token reuse)
\end{itemize}
}

\subsection{Memory Corruption Vulnerabilities}
{
\textbf{Types:}
\begin{itemize}[noitemsep]
  \item Buffer overflows (no/incorrect bounds checking)
  \item Indexing errors
  \item Arbitrary memory writes
  \item Use-after-free
  \item Type confusion
\end{itemize}
}

\subsection{Protection Mechanisms (Revisited)}
{
\begin{itemize}[noitemsep]
  \item \textbf{ASLR (Address Space Layout Randomization):} Randomizes memory locations
  \item \textbf{NX/DEP (No-eXecute/Data Execution Prevention):} Marks memory as non-executable
  \item \textbf{Stack Canaries:} Detect stack corruption before function return
\end{itemize}
}

\subsection{Return-Oriented Programming (ROP)}
{
\textbf{Concept:}
\begin{itemize}[noitemsep]
  \item Reuses existing code (gadgets) to perform operations
  \item Gadgets end in \texttt{ret} instructions to chain control flow
  \item Bypasses NX/DEP as no new code is injected
\end{itemize}

\textbf{Steps to Exploit with ROP:}
\begin{enumerate}[noitemsep]
  \item Find target function address
  \item Determine offset to return address
  \item Overwrite return address with function address
  \item If parameters are needed, add them to stack + a gadget (e.g., \texttt{pop; pop; ret;})
  \item Chain multiple calls using gadgets
\end{enumerate}
}

\subsection{Challenges and Countermeasures}
{
\textbf{Stack Canaries:} Prevent direct ret address overwrite; workaround:
\begin{itemize}[noitemsep]
  \item Overwrite function pointer instead
  \item Leak and reuse canary value
  \item Use jump-over techniques
\end{itemize}

\textbf{ASLR:}
\begin{itemize}[noitemsep]
  \item Makes gadget address guessing hard
  \item Mitigated via info leaks or brute force (easier on 32-bit)
\end{itemize}

\textbf{Control Flow Integrity (CFI):}
\begin{itemize}[noitemsep]
  \item Detects invalid indirect calls
  \item Requires programs to be compiled with special flags (e.g., \texttt{/guard:cf})
\end{itemize}
}

\subsection{Conclusion}
{
\begin{itemize}[noitemsep]
  \item ROP is powerful but challenged by modern protections
  \item Still useful where protections are weak or missing (e.g., IoT, legacy systems)
  \item New attack trends focus on memory read/write primitives, logic flaws, and side-channels
\end{itemize}
}


\subsection{Lab: Return-Oriented Programming (ROP)}
{
\textbf{Goal:} Exploit a buffer overflow using ROP to bypass NX and partially mitigate ASLR.

\textbf{Target Setup:}
\begin{itemize}[noitemsep]
  \item C binary with buffer overflow
  \item Protections: NX enabled, ASLR (may be disabled), no stack canaries
  \item Architecture: x86\_64
\end{itemize}

\textbf{Tools Used:}
\begin{itemize}[noitemsep]
  \item \texttt{gdb} – debugging and memory inspection
  \item \texttt{pwntools} – Python scripting for exploit automation
  \item \texttt{ROPgadget} – find usable gadgets in binaries
  \item \texttt{objdump -d <binary>} – disassemble to find function addresses
  \item \texttt{readelf -s <binary>} – find symbols like \texttt{system}, \texttt{/bin/sh}
  \item \texttt{cyclic}, \texttt{cyclic -l <value>} (from pwntools) – determine buffer overflow offset
  \item \texttt{setarch `uname -m` -R <binary>} – run binary with ASLR disabled
\end{itemize}

\textbf{Exploitation Steps:}
\begin{enumerate}[noitemsep]
  \item Find overflow offset using \texttt{cyclic} pattern
  \item Locate \texttt{system} and \texttt{/bin/sh} address
  \item Find gadget to control \texttt{RDI} (e.g., \texttt{pop rdi; ret;})
  \item Build payload:
    \begin{itemize}
      \item Padding to offset
      \item Gadget to set argument
      \item Call to target function
    \end{itemize}
  \item Test with \texttt{gdb} and launch exploit
\end{enumerate}


\textbf{Key Concepts Practiced:}
\begin{itemize}[noitemsep]
  \item Overwriting return address with controlled data
  \item Chaining existing instructions (gadgets) to invoke desired code
  \item Understanding calling convention (x86\_64 → first arg in RDI)
\end{itemize}
}
